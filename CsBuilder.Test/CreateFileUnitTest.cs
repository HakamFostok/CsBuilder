using Microsoft.CodeAnalysis;

namespace CsBuilder.Test;

public class CreateFileUnitTest
{
    [Fact]
    public void CreateSimpleFile()
    {
        FieldOrPropertyToDispose[] array = new FieldOrPropertyToDispose[]
        {
            new FieldOrPropertyToDispose("field1", true, null, null, true, true, true),
            new FieldOrPropertyToDispose("field2", false, null, null, false, true, true),
            new FieldOrPropertyToDispose("field3", false, null, null, true, false, false),
        };

        string file = SourceGenerationHelper.ImplementDisposablePattern(
            new DisposableToGenerate("MyClass", "Project", false,
            true, true, array,
            true, true,
            true, true));
    }
}

public static class SourceGenerationHelper
{
    internal static string ImplementDisposablePattern(DisposableToGenerate classToGenerate)
    {
        ICsFileBuilder csFileBuilder = new CsFileBuilder();

        csFileBuilder.AddAutoGeneratedHeader("Disposer")
                     .AddEmptyLine();

        if (classToGenerate.ImplementIAsyncDisposable)
            csFileBuilder.AddStatements("#nullable enable")
                         .AddEmptyLine()
                         .AddUsing("ValueTaskAlias = global::System.Threading.Tasks.ValueTask")
                         .AddEmptyLine();

        csFileBuilder.AddNamespace(classToGenerate.Namespace, true);

        GenerateBaseImplementation(csFileBuilder, classToGenerate);

        if (classToGenerate.ImplementDisposable)
            GenerateDisposableImplementation(csFileBuilder, "IDisposable", false, classToGenerate);

        if (classToGenerate.ImplementIAsyncDisposable)
            GenerateDisposableImplementation(csFileBuilder, "IAsyncDisposable", true, classToGenerate);

        csFileBuilder.EndNamespace();

        return csFileBuilder.Build();
    }

    private static void GenerateBaseImplementation(ICsFileBuilder builder, DisposableToGenerate classToGenerate)
    {
        builder.AddStatementAndStartBlock($"partial class {classToGenerate.Name}")
               .AddStatements("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]",
                                    "private bool disposed = false;")
               .AddProtectedDisposed(classToGenerate.IsSealed)
               .AddEmptyLine()
               .AddFinializer(classToGenerate.Name, !classToGenerate.ImplementDisposable && classToGenerate.ImplementIAsyncDisposable)
               .EndBlock()
               .AddEmptyLine();
    }

    private static void GenerateDisposableImplementation(ICsFileBuilder builder, string interfaceName, bool isAsync, DisposableToGenerate classToGenerate)
    {
        builder.AddStatementAndStartBlock($"partial class {classToGenerate.Name} : global::System.{interfaceName}")
               .AddCallbackFunctions(isAsync, classToGenerate)
               .AddDisposeBoolean(isAsync, classToGenerate)
               .AddEmptyLine()
               .AddDispose(isAsync)
               .EndBlock()
               .AddEmptyLine();
    }

    private static ICsFileBuilder AddProtectedDisposed(this ICsFileBuilder builder, bool isSealed)
    {
        string accessModifier = isSealed ? "private" : "protected";
        builder.AddStatements($"{accessModifier} bool Disposed => disposed;");
        return builder;
    }

    private static ICsFileBuilder AddDispose(this ICsFileBuilder builder, bool isAsync)
    {
        if (isAsync == false)
            builder.AddStatementAndStartBlock("public void Dispose()")
                   .AddStatements("Dispose(true);");
        else
            builder.AddStatementAndStartBlock("public async ValueTaskAlias DisposeAsync()")
                   .AddStatements("await DisposeAsync(true);");

        builder.AddStatements("global::System.GC.SuppressFinalize(this);")
               .EndBlock();

        return builder;
    }

    private static ICsFileBuilder AddCallbackFunctions(this ICsFileBuilder builder, bool isAsync, DisposableToGenerate disposableToGenerate)
    {
        if (!isAsync)
        {
            if (disposableToGenerate.GenerateDisposeManagedCallback)
                builder.AddStatements($"private global::System.Action? DisposeManaged;");

            if (disposableToGenerate.GenerateDisposeUnmanagedCallback)
                builder.AddStatements($"private global::System.Action? DisposeUnmanaged;");

            if (disposableToGenerate.GenerateDisposeManagedCallback ||
                disposableToGenerate.GenerateDisposeUnmanagedCallback)
                builder.AddEmptyLine();
        }
        else
        {
            if (disposableToGenerate.AsyncGenerateDisposeManagedCallback)
                builder.AddStatements($"private global::System.Func<ValueTaskAlias>? DisposeManagedAsync;");

            if (disposableToGenerate.AsyncGenerateDisposeUnmanagedCallback)
                builder.AddStatements($"private global::System.Func<ValueTaskAlias>? DisposeUnmanagedAsync;");

            if (disposableToGenerate.AsyncGenerateDisposeManagedCallback ||
                disposableToGenerate.AsyncGenerateDisposeUnmanagedCallback)
                builder.AddEmptyLine();
        }

        return builder;
    }

    private static ICsFileBuilder AddFinializer(this ICsFileBuilder builder, string className, bool isAsync)
    {
        string statement = isAsync ? "DisposeAsync(false).GetAwaiter().GetResult();" : "Dispose(false);";

        builder.AddStatementAndStartBlock($"~{className}()")
               .AddStatements(statement)
               .EndBlock();

        return builder;
    }

    private static ICsFileBuilder AddDisposeBoolean(this ICsFileBuilder builder,
        bool isAsync,
        DisposableToGenerate disposableToGenerate)
    {
        if (isAsync)
            AddDisposeAsyncBooleanLogic(builder, disposableToGenerate);
        else
            AddDisposeBooleanLogic(builder, disposableToGenerate);

        return builder;
    }

    private static void AddDisposeBooleanLogic(this ICsFileBuilder builder, DisposableToGenerate disposableToGenerate)
    {
        string methodPrefix = disposableToGenerate.IsSealed ? "private" : "protected virtual";
        string[] variablesName = disposableToGenerate.FieldsOrProperties
            .Select(x => GetDisposeStatement(x, false)).ToArray();

        builder.AddStatementAndStartBlock($"{methodPrefix} void Dispose(bool disposing)")
               .AddIfBlock("!disposed", "return;")
               .AddEmptyLine()
               .AddStatementAndStartBlock("if (disposing)")
               .AddStatements(variablesName)
               .AddStatementsIf(disposableToGenerate.GenerateDisposeManagedCallback, "DisposeManaged?.Invoke();")
               .EndBlock()
               .AddStatementsIf(disposableToGenerate.GenerateDisposeUnmanagedCallback, "DisposeUnmanaged?.Invoke();")
               .AddStatements("", "disposed = true;")
               .EndBlock();
    }

    private static void AddDisposeAsyncBooleanLogic(this ICsFileBuilder builder, DisposableToGenerate disposableToGenerate)
    {
        string methodPrefix = disposableToGenerate.IsSealed ? "private" : "protected virtual";
        string[] variablesName = disposableToGenerate.FieldsOrProperties
            .Select(x => GetDisposeStatement(x, true)).ToArray();

        builder.AddStatementAndStartBlock($"{methodPrefix} async ValueTaskAlias DisposeAsync(bool disposing)")
               .AddIfBlock("!disposed", "await ValueTaskAlias.FromResult(ValueTaskAlias.CompletedTask);")
               .AddEmptyLine()
               .AddStatementAndStartBlock("if (disposing)")
               .AddStatements(variablesName)
               .AddStatementsIf(disposableToGenerate.AsyncGenerateDisposeManagedCallback, "await (DisposeManagedAsync?.Invoke() ?? ValueTaskAlias.CompletedTask);")
               .EndBlock()
               .AddStatementsIf(disposableToGenerate.AsyncGenerateDisposeUnmanagedCallback, "await(DisposeUnmanagedAsync?.Invoke() ?? ValueTaskAlias.CompletedTask);")
               .AddStatements("", "disposed = true;")
               .EndBlock();
    }

    public static string GetDisposeStatement(FieldOrPropertyToDispose fieldOrProperty, bool isAsync)
    {
        string needAwait = isAsync && fieldOrProperty.ImplementIAsyncDisposable ? "await" : "";
        string needAsync = isAsync && fieldOrProperty.ImplementIAsyncDisposable ? "Async" : "";

        string disposeStatement = $"{needAwait} {fieldOrProperty.Name}.Dispose{needAsync}();{Environment.NewLine}";
        string setToNullStatement = fieldOrProperty.SetToNull ? $"{fieldOrProperty.Name} = null;{Environment.NewLine}" : "";

        return $"{disposeStatement}{setToNullStatement}";
    }
}

public readonly struct DisposableToGenerate
{
    public readonly string Name;
    public readonly string Namespace;
    public readonly bool IsSealed;
    public readonly bool ImplementDisposable;
    public readonly bool ImplementIAsyncDisposable;
    public readonly FieldOrPropertyToDispose[] FieldsOrProperties;
    public readonly bool GenerateDisposeManagedCallback;
    public readonly bool GenerateDisposeUnmanagedCallback;
    public readonly bool AsyncGenerateDisposeManagedCallback;
    public readonly bool AsyncGenerateDisposeUnmanagedCallback;

    public DisposableToGenerate(
        string name,
        string ns,
        bool isSealed,
        bool implementDisposable,
        bool implementIAsyncDisposable,
        FieldOrPropertyToDispose[] fieldsOrProperties,
        bool generateDisposeManagedCallback,
        bool generateDisposeUnmanagedCallback,
        bool asyncGenerateDisposeManagedCallback,
        bool asyncGenerateDisposeUnmanagedCallback)
    {
        Name = name;
        Namespace = ns;
        IsSealed = isSealed;
        ImplementDisposable = implementDisposable;
        ImplementIAsyncDisposable = implementIAsyncDisposable;
        FieldsOrProperties = fieldsOrProperties;
        GenerateDisposeManagedCallback = generateDisposeManagedCallback;
        GenerateDisposeUnmanagedCallback = generateDisposeUnmanagedCallback;
        AsyncGenerateDisposeManagedCallback = asyncGenerateDisposeManagedCallback;
        AsyncGenerateDisposeUnmanagedCallback = asyncGenerateDisposeUnmanagedCallback;
    }
}

public readonly struct FieldOrPropertyToDispose
{
    public readonly string Name;
    public readonly bool IsProperty;
    public readonly Location? Location;
    public readonly ITypeSymbol Type;
    public readonly bool ImplementDisposable;
    public readonly bool ImplementIAsyncDisposable;
    public readonly bool SetToNull;

    public FieldOrPropertyToDispose(
        string name,
        bool isProperty,
        Location? location,
        ITypeSymbol type,
        bool implementDisposable,
        bool implementIAsyncDisposable,
        bool setToNull)
    {
        Name = name;
        IsProperty = isProperty;
        Location = location;
        Type = type;
        ImplementDisposable = implementDisposable;
        ImplementIAsyncDisposable = implementIAsyncDisposable;
        SetToNull = setToNull;
    }
}

